# Pact Contract Testing for Microservices - Tutorial Project

This project demonstrates contract testing between a NestJS consumer and a Spring Boot producer using Pact. Follow these steps to set up, generate, and verify contracts in a microservices architecture.

## Prerequisites

- Docker & Docker Compose
- Node.js (14+)
- Java 17+
- Gradle

## Setup Instructions

### 1. Clone the Repository

    git clone git@github.com:kaushald/contract-testing-tutorial.git
    cd contract-testing-tutorial

### 2. Start the Pact Broker

Start the Pact Broker with Docker Compose:

    docker-compose up -d

This sets up a Pact Broker at `http://localhost:9292`.

### 3. Set Up the Consumer (NestJS)

1.  Navigate to `pact-consumer`:

        cd pact-consumer

2.  Install dependencies:

        npm install

3.  Run the consumer test to generate the Pact contract:

        npm test test/pact/consumer.data.pact.spec.ts
        npm test test/pact/consumer.user.pact.spec.ts

4.  Publish the Pact to the broker:

        pact-broker publish ./pacts --consumer-app-version 1.0.0 --broker-base-url http://localhost:9292

### 4. Set Up the Producer (Spring Boot)

1.  In a new terminal, navigate to `pact-producer`:

        cd pact-producer

2.  Run the Pact verification test:

        ./gradlew test

This will verify the provider’s compliance with the contract in the Pact Broker.

### 5. Verify Pact Contract in the Broker UI

Go to `http://localhost:9292` to view published Pact contracts and verification results.

---

## Project Structure

- **pact-consumer/**: NestJS-based consumer app with Pact tests.
- **pact-producer/**: Spring Boot producer app with verification tests.
- **docker-compose.yml**: Configuration for the Pact Broker.

## Troubleshooting

Ensure:

- Docker and Docker Compose are running.
- The Pact Broker is accessible at `http://localhost:9292`.
- Each service (consumer and producer) is correctly configured.

## Explanation of Contract Testing with Pact

This project demonstrates how Pact facilitates **contract testing** between a consumer (NestJS) and a provider (Spring Boot) in a microservices architecture. Contract testing helps ensure that services can communicate correctly by enforcing a shared understanding, or "contract," between them.

### Key Concepts

1. **Consumer-Driven Contracts**:
   - In contract testing, the **consumer** (the service that requests data) defines its expectations of the provider. This includes endpoint paths, response formats, and data structures.
   - **Consumer-driven contracts** mean that the consumer sets the requirements, and the provider must fulfill these requirements to maintain compatibility.
2. **Provider**:

   - The **provider** (the service that supplies data) implements endpoints that meet the consumer's expectations.
   - Using Pact, we verify that the provider’s actual responses align with the contract defined by the consumer, ensuring a consistent interface between services.

3. **Pact**:

   - Pact is a tool that facilitates contract testing by allowing consumers to define and test their expectations as contracts, which are then verified against the provider.
   - It enables **isolated testing**, so each service (consumer and provider) can be tested independently without requiring an actual live integration.

4. **Pact Contracts (Pact Files)**:

   - Pact contracts, or Pact files, are generated by running consumer tests. They contain the expected interactions with the provider, including:
     - **State**: The required state of the provider for a given interaction (e.g., "user with ID 1 has orders").
     - **Request**: The HTTP method, path, and any headers the consumer will use.
     - **Expected Response**: The status code, headers, and body format that the consumer expects from the provider.
   - These contracts are published to a Pact Broker, which serves as a central hub for storing, versioning, and sharing contracts across services.

5. **Mocks in Consumer Tests**:
   - In consumer testing, Pact generates **mock responses** based on the expected responses defined in the contract.
   - This allows the consumer to test its code against predefined provider behavior without needing the actual provider service to be running.
   - Once these tests pass, Pact generates a Pact file, documenting the consumer’s expectations.

### Provider Verification in Pact

Pact’s **provider verification** process ensures the provider can fulfill the contract as expected by the consumer.

1. **Fetching the Pact File**:

   - When verifying the provider, Pact retrieves the Pact file either from the Pact Broker or a local source. This file contains the consumer's contract, detailing required interactions with the provider.

2. **Provider Verification (No Mocking)**:

   - Unlike unit tests, **Pact does not mock responses in provider verification**. Instead, it tests the provider’s **actual live responses**.
   - Pact sends real HTTP requests to the provider’s endpoints, comparing the responses to the expected structure in the Pact file.

3. **Provider State Setup with `@State` Methods**:

   - Each interaction defined in the Pact file may require the provider to be in a certain state. For instance, when the consumer expects a response with "user with ID 1 has orders," the provider must have this data ready.
   - `@State` methods in the provider test are responsible for setting up this state. These methods prepare the provider to respond as expected, often by inserting data into databases or setting up in-memory data.
   - For example:
     ```java
     @State("user with ID 1 has orders")
     public void userHasOrdersState() {
         // Setup data for user ID 1 with orders, if necessary.
     }
     ```

4. **Provider Verification Test**:
   - The verification test annotated with `@PactVerificationTestTemplate` initiates Pact’s verification process:
     ```java
     @TestTemplate
     @ExtendWith(PactVerificationSpringProvider.class)
     void pactVerificationTestTemplate(PactVerificationContext context) {
         context.verifyInteraction();
     }
     ```
   - This test triggers Pact to call each interaction in the Pact file, comparing the real provider responses with the contract expectations. The test passes if the responses match, confirming the provider’s compliance with the contract.

### Benefits of Pact and Contract Testing

- **Early Error Detection**: Contract testing identifies issues in development, catching breaking changes before they reach production.
- **Seamless Integration**: By ensuring consumers and providers adhere to shared expectations, contract testing minimizes integration failures.
- **Isolation and Efficiency**: Pact allows services to be tested in isolation, avoiding the need for complex integration environments.
- **Centralized Contract Management**: The Pact Broker serves as a shared repository, enabling version control, collaboration, and tracking of contract changes over time.

Contract testing with Pact offers a robust, flexible approach for verifying service compatibility in microservices architectures, ensuring that consumers and providers can evolve independently while maintaining reliable interactions.

## Learn More

Visit the [Pact Documentation](https://docs.pact.io/) for in-depth guidance on contract testing with Pact.
